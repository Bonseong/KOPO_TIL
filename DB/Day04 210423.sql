SELECT ENAME, HIREDATE FROM EMP;
SELECT ENAME, HIREDATE FROM EMP ORDER BY ENAME; -- ENAME 기준으로 정렬 (defalut : asc)
SELECT ENAME, HIREDATE FROM EMP ORDER BY ENAME asc; -- ENAME 기준으로 오름차순 정렬 (코드의 명료성을 위해)
SELECT ENAME, HIREDATE FROM EMP ORDER BY ENAME desc; -- ENAME 기준으로 내림차순 정렬

/* Naming Rule (명명규칙)
각 개발자마다 코딩스타일이나 변수명, 클래스명 등 다르기 때문에 정한 규칙
asc, desc 같은 것은 소문자로
*/a

SELECT ENAME, SAL, HIREDATE FROM EMP ORDER BY ENAME;
SELECT ENAME, SAL, HIREDATE FROM EMP ORDER BY 2; -- SELECT LIST의 두번째 컬럼을 기준으로 정렬
SELECT ENAME, SAL*12 as annual_SAL FROM EMP ORDER BY annual_SAL; -- alias 를 기준으로
SELECT EMPNO, ENAME, COMM, JOB FROM EMP ORDER BY COMM*12;

SELECT DEPTNO,JOB,ENAME FROM EMP ORDER BY DEPTNO; 
SELECT DEPTNO,JOB,ENAME FROM EMP ORDER BY DEPTNO, JOB; -- 첫번째 정렬 기준 : DEPTNO, 두번째 정렬 기준 : JOB
SELECT DEPTNO,JOB,ENAME FROM EMP ORDER BY DEPTNO, JOB desc; -- 첫번째 정렬 기준 : DEPTNO, 두번째 정렬 기준 : JOB (내림차순)

SELECT ENAME, HIREDATE FROM EMP ORDER BY SAL desc; -- SELECT 하지 않은 컬럼을 기준으로 정렬을 할 수는 있지만, 의미는 없다.

SELECT EMPNO, COMM FROM EMP ORDER BY COMM asc; -- NULL이 가장 큰 값으로 간주
SELECT EMPNO, COMM FROM EMP ORDER BY COMM desc;

SELECT JOB FROM EMP;
SELECT ALL JOB FROM EMP;

SELECT DISTINCT JOB FROM EMP; -- ANSI 표준
SELECT UNIQUE JOB FROM EMP;

SELECT DISTINCT DEPTNO, JOB FROM EMP; -- 순서쌍에 대한 중복 제거

--SELECT DISTINCT JOB, DISTINCT DEPTNO FROM EMP;
--SELECT JOB, DISTINCT DEPTNO FROM EMP;

SELECT COMM FROM EMP WHERE COMM IS NOT NULL; -- null이 아닌 것에 대한 출력
SELECT DISTINCT COMM FROM EMP; -- null 또한 중복을 제거하고 출력한다

SELECT COMM FROM EMP WHERE COMM IS NOT NULL; -- null이 아닌 것에 대한 출력
SELECT DISTINCT COMM FROM EMP; -- null 또한 중복을 제거하고 출력한다


SELECT DEPTNO, ENAME, DECODE(DEPTNO, 10, 'ACCOUNTING', 20, 'RESEARCH', 30, 'SALES', 'ETC')
FROM EMP
ORDER BY DEPTNO;

SELECT COMM, DECODE(COMM, NULL, -99, COMM) FROM EMP;

SELECT GREATEST(3000, 1500, 2100, 5000), LEAST(3000,1500,2100,5000) FROM DUAL; -- GREATEST : 최댓값, LEAST : 최솟값 리턴

SELECT DEPTNO,ENAME,SAL,DECODE(GREATEST(SAL,5000),SAL,'HIGH',DECODE(GREATEST(SAL,2500),SAL,'MID','LOW'))
FROM EMP 
ORDER BY DEPTNO; -- DECODE는 == 만 가능하기 때문에, 비교연산이 불가함 => CASE로 대체

SELECT DEPTNO, ENAME, SAL, COMM,
DECODE(GREATEST(COMM, 5000), COMM, 'HIGH', DECODE(GREATEST(COMM, 2500), COMM, 'MID', 'LOW'))
FROM EMP
ORDER BY DEPTNO;

SELECT DEPTNO, ENAME, SAL,
    CASE WHEN SAL>=5000 THEN 'HIGH'
        WHEN SAL>=2500 THEN 'MID'
        WHEN SAL<2500 THEN 'LOW'
    ELSE 'UNKNOWN'
    END
FROM EMP
ORDER BY DEPTNO;

SELECT DEPTNO, ENAME, SAL,
    CASE WHEN SAL >=5000 THEN 'HIGH'
        WHEN SAL >=2500 THEN 'MID'
        WHEN SAL BETWEEN 300 AND 2500 THEN 'LOW'
    ELSE 'UNKNOWN'
    END
FROM EMP
ORDER BY DEPTNO;

SELECT DEPTNO, ENAME, SAL,
    CASE WHEN COMM >=5000 THEN 'HIGH'
        WHEN COMM >=2500 THEN 'MID'
        WHEN COMM BETWEEN 300 AND 2500 THEN 'LOW'
    ELSE 'UNKNOWN'
    END
FROM EMP
ORDER BY DEPTNO;

SELECT DEPTNO,
    CASE DEPTNO
        WHEN 10 THEN 'ACCOUNTING'
        WHEN 20 THEN 'RESEARCH'
        WHEN 30 THEN 'SALES'
        WHEN 40 THEN 'OPERATIONS'
        ELSE 'UNKNOWN'
    END AS DNAME
FROM EMP
ORDER BY DEPTNO;

SELECT SAL,
    CASE
        WHEN SAL>=1000 THEN 1
        WHEN SAL>=2000 THEN 2
        WHEN SAL>=3000 THEN 3
        WHEN SAL>=4000 THEN 4
        WHEN SAL>=5000 THEN 5
        ELSE 0
    END AS SAL_CHK
FROM EMP
ORDER BY SAL; --거의 대부분의 값이 SAL>=1000의 조건에 해당되기 때문에 옳지 않은 방법

SELECT SAL,
    CASE
        WHEN SAL>=5000 THEN 5
        WHEN SAL>=4000 THEN 4
        WHEN SAL>=3000 THEN 3
        WHEN SAL>=2000 THEN 2
        WHEN SAL>=1000 THEN 1
        ELSE 0
    END AS SAL_CHK
FROM EMP
ORDER BY SAL;

SELECT JOB,
    NULLIF(JOB, 'MANAGER'),
    CASE
        WHEN JOB = 'MANAGER' THEN NULL
        ELSE JOB
    END AS NULLIF_SIM
FROM EMP;    


SELECT * FROM EMP;

SELECT ROWNUM, ENAME, DEPTNO, SAL FROM EMP;

SELECT ROWNUM, ENAME, DEPTNO, SAL FROM EMP
ORDER BY DEPTNO, SAL; -- ROWNUM은 레코드별 절대적으로 있는 숫자가 아님

SELECT ROWNUM, ENAME, DEPTNO, SAL FROM EMP
WHERE DEPTNO IN (10,20)
ORDER BY DEPTNO, SAL; 

SELECT ENAME, DEPTNO, SAL FROM EMP WHERE ROWNUM = 1;

SELECT ENAME, DEPTNO, SAL FROM EMP WHERE ROWNUM <= 3;
SELECT ROWNUM, ENAME, DEPTNO, SAL FROM EMP;

SELECT ENAME,DEPTNO,SAL FROM EMP WHERE ROWNUM<100;







SELECT * FROM DEPT;
------------
SELECT DEPTNO FROM EMP
UNION
SELECT DEPTNO FROM DEPT;

SELECT DEPTNO FROM EMP
UNION ALL
SELECT DEPTNO FROM DEPT;

SELECT DEPTNO FROM DEPT
INTERSECT
SELECT DEPTNO FROM EMP;


SELECT DEPTNO FROM DEPT
INTERSECT
SELECT DEPTNO FROM EMP;


SELECT ENAME, DEPTNO, SAL,
    CASE
        WHEN DEPTNO = 10 THEN TRUNC(SAL*0.003)
        WHEN DEPTNO = 20 THEN TRUNC(SAL*0.2)
        WHEN DEPTNO = 30 THEN TRUNC(SAL*0.1)
        ELSE TRUNC(SAL*0.01)
    END AS BONUS
FROM EMP
ORDER BY DEPTNO, BONUS;
        
SELECT DEPTNO, ENAME, SAL FROM
    (SELECT DEPTNO, ENAME, SAL
    FROM EMP
    ORDER BY SAL DESC)
WHERE ROWNUM <=5;


select dbms_random.value(1,5) from dual;