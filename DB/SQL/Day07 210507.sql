--SELECT DNAME, ENAME, JOB, SAL FROM EMP, DEPT WHERE DEPTNO=DEPTNO; -- 에러

SELECT DNAME, ENAME, JOB, SAL FROM EMP, DEPT WHERE EMP.DEPTNO=DEPT.DEPTNO;
-- 스키마의 정보는 데이터사전에 저장되어 있음
-- DBMS는 해당 스키마의 테이블 구조, 컬럼을 가지고 있음

SELECT DNAME, ENAME, JOB, SAL FROM EMP, DEPT
    WHERE EMP.DEPTNO=DEPT.DEPTNO AND
    EMP.JOB IN ('MANAGER', 'CLERK') ORDER BY DNAME; -- 조인과 필터링을 같이 수행해야 할 경우, 필터링이 먼저 수행되고 조인 수행
    
SELECT DEPT.DNAME, EMP.ENAME, EMP.JOB, EMP.SAL FROM SCOTT.EMP, SCOTT.DEPT -- SCOTT소유의 EMP, SCOTT 소유의 DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;
-- OBJECT NAME 표기법 : [SCHEMA.]OBJECT_NAME
-- COLUMN NAME 표기법 : [TABLE_NAME.]COLUMN_NAME

SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO;
-- TABLE ALIAS 용도 : 편의성, 가독성, SELF JOIN시에는 필수적으로 사용, 동일 컬럼명이 존재하는 경우

SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;
-- [ANSI/ISO], ON JOIN 조건 표기

SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
WHERE E.DEPTNO IN (10, 20) AND D.DNAME = 'RESEARCH';
-- WHERE 조건






SELECT E.ENAME, E.JOB, E.SAL, S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; -- EMP의 SALARY가 SALARY의 LOWSAL과 HISAL의 범위에 맞는 등급 표시

SELECT DNAME, ENAME, JOB, SAL, GRADE FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; -- 3개의 테이블, 2번의 조인
-- EMP의 SALARY가 SALARY의 LOWSAL과 HISAL의 범위에 맞는 등급 표시

SELECT E.ENAME, E.JOB, E.SAL, S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND E.DEPTNO IN (10, 30)
ORDER BY E.ENAME;

SELECT E.ENAME, E.JOB, E.SAL, S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL < S.LOSAL AND E.DEPTNO IN (10, 30)
ORDER BY E.ENAME; -- 의미없는 데이터 (자기보다 낮은 등급의 데이터 모두 출력하기 때문에)






SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DNAME; -- EMP테이블과 DEPT테이블 모두 DEPTNO가 10, 20, 30 있기 때문에 모두 출력

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO ORDER BY D.DEPTNO; -- 위 쿼리와 동일한 결과 출력

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DNAME; -- EMP 테이블의 DEPTNO는 DEPT 테이블의 DEPTNO의 데이터보다 부족하기 때문에 (40 데이터) 40데이터 출력, 나머지 정보는 null로 출력

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO(+)
ORDER BY D.DNAME; -- DEPT의 DEPTNO는 EMP의 DEPTNO에 비해 데이터가 충분하기 때문에 null 없이 출력 가능
-- 불필요한 연산

SELECT D.DNAME, NVL(E.ENAME, '비상근 부서'), E.JOB, E.SAL FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DNAME; -- NULL에 대한 처리를 위해

--SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D
--WHERE E.DEPTNO(+) = D.DEPTNO(+)
--ORDER BY D.DNAME;
-- ORACLE은 양방향 OUTER JOIN을 지원하지 않음







SELECT E.DEPTNO, D.DNAME, E.ENAME FROM SCOTT.EMP E LEFT OUTER JOIN SCOTT.DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO;

SELECT E.DEPTNO, D.DNAME, E.ENAME FROM SCOTT.EMP E RIGHT OUTER JOIN SCOTT.DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY D.DEPTNO; -- null 출력

SELECT D.DEPTNO, D.DNAME, E.ENAME FROM SCOTT.EMP E FULL OUTER JOIN SCOTT.DEPT D
ON E.DEPTNO = D.DEPTNO
ORDER BY E.DEPTNO; -- FULL OUTER JOIN, 양 테이블에 컬럼을 기준으로 서로 없는 값들을 null로 채워 출력






SELECT E.ENAME||' ''S MANAGER IS ' ||M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO
ORDER BY M.ENAME;



SELECT ENAME, JOB, DNAME FROM EMP, DEPT;
SELECT ENAME, JOB, DNAME FROM EMP, DEPT WHERE EMP.SAL>2000 AND DEPT.DEPTNO IN (10, 20);


