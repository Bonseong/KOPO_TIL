ALTER TABLE DEPT MODIFY (DNAME VARCHAR2(18), LOC VARCHAR2(20));

INSERT INTO DEPT VALUES(50, '연구소1', '서울'); -- 컬럼명 생략
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(51, '연구소2', '대전'); -- 컬럼명 명시 (더 좋은 방법)

-- 해당컬럼을 생략하는 경우 NULL로 처리
INSERT INTO DEPT VALUES('중부영업점', '대구'); -- 에러 : 컬럼의 수와 일치하지 않음
INSERT INTO DEPT(DNAME, LOC) VALUES('중부영업점', '대구'); -- 명시하지 않은 컬럼이 있는 경우 null로 처리

-- INSERT 시에 특정 컬럼에 NULL 삽입 방법
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(52, '북부영업점', NULL); -- 명시적 방법
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(52, '북부영업점', '');

INSERT INTO DEPT(DEPTNO, DNAME) VALUES(52, '북부영업점'); -- 암시적방법 : 컬럼명 생략

SELECT DEPTNO,DNAME,NVL(LOC,'미지정지역') AS LOC FROM DEPT; 
ROLLBACK;
SELECT * FROM DEPT;

UPDATE DEPT SET DNAME = '중부연구소' WHERE DEPTNO = 50; -- 단일 컬럼
UPDATE DEPT SET DNAME = '북서부연구소', LOC = '인천' WHERE DEPTNO = 51; -- 복수 컬럼

UPDATE DEPT SET LOC = '미개척지역'; -- WHERE절 생략시 전체 ROW 처리

SELECT * FROM DEPT;
ROLLBACK;


DELETE FROM DEPT WHERE LOC IS NULL;
DELETE DEPT; -- FROM 생략 가능, WHERE 없으면 전체 데이터 소멸
SELECT * FROM DEPT;
ROLLBACK;





INSERT INTO BONUS(ENAME, JOB, SAL, COMM) SELECT ENAME, JOB, SAL, COMM FROM EMP;
SELECT * FROM BONUS;
ROLLBACK;
SELECT * FROM BONUS;

INSERT INTO BONUS(ENAME, JOB, SAL, COMM)
SELECT ENAME, JOB, SAL, DECODE(DEPTNO, 10, SAL*0.3, 20, SAL*0.2) + NVL(COMM,0)
FROM EMP
WHERE DEPTNO IN (10, 20);

SELECT * FROM BONUS;
ROLLBACK;



UPDATE EMP SET COMM = (SELECT AVG(COMM)/2 FROM EMP) WHERE COMM IS NULL OR COMM = 0;
SELECT * FROM EMP;
ROLLBACK;

DELETE FROM BONUS WHERE SAL > (SELECT AVG(SAL) FROM EMP);
SELECT * FROM BONUS;



ROLLBACK; -- TRANSACTION END
INSERT INTO DEPT(DEPTNO, DNAME, LOC) VALUES(90, '신규사업부', '경기도'); -- TRANSACTION START
UPDATE EMP SET DEPTNO=90 WHERE DEPTNO = 30; -- 진행중
DELETE FROM DEPT WHERE DEPTNO = 30; -- 진행중
    SELECT * FROM DEPT;
    SELECT * FROM EMP WHERE DEPTNO = 30; -- 진행중인 상태에서 조회
ROLLBACK; -- TRANSACTION END
    SELECT * FROM DEPT;
    SELECT * FROM EMP WHERE DEPTNO = 30; -- 종료 후 조회
    


INSERT INTO EMP(EMPNO,ENAME, JOB, SAL) VALUES(1111, '오라클', 'DBA', 3500); -- TRANSACTION START
UPDATE EMP SET SAL = SAL*(1/1.3);
COMMIT; -- TRANSACTION END
ROLLBACK; -- TRANSACTION END (이미 종료되었기 때문에 아무것도 되돌릴게 없음)


INSERT INTO EMP(EMPNO, ENAME, DEPTNO) VALUES(9999, 'OCPOK', 20); -- TRANSACTION START
ALTER TABLE EMP ADD(SEX CHAR(1) DEFAULT 'M'); -- TRANSACTION 암시적 종료
ROLLBACK; -- TRANSACTION 종료, 아무변화도 일어나지 않음 취소범위 : 트랜잭션이 시작된 시점부터
DESC EMP;
ALTER TABLE EMP DROP COLUMN SEX; -- TRANSACTION 암시적 종료
ROLLBACK; -- 아무변화도 일어나지 않음
DESC EMP;



ROLLBACK;
SELECT /* BEFORE TRANSACTION*/ EMPNO, SAL FROM EMP WHERE EMPNO IN (7788, 7902); -- 쿼리 내 주석
DELETE FROM EMP WHERE DEPTNO = 10; -- 트랜잭션 시작, 정상적으로 실행
UPDATE /* STATEMENT LEVEL ROLLBACK */ EMP SET SAL = 123456789 WHERE EMPNO = 7788;
-- NUMBER(7,2)므로 불가 // NUMBER(7,2) : 정수 5자리, 숫자 2자리
-- 해당 UPDATE만 ROLLBACK 자동 처리
UPDATE EMP SET SAL = 1234 WHERE EMPNO = 7902; -- 정상적으로 실행
COMMIT; -- 트랜잭션 종료, 원자성을 보장하지 않음

-- SQL 명령어로만 트랜잭션 제어가 안된다!
SELECT * FROM EMP;


-- STATEMENT LEVEL ROLLBACK
/*
만약 SAL이 NUMBER(7,2)인데
SAL = SAL * 10을 수행한다고 하면
SAL이 5자리를 넘어가는 순간 5자리를 넘어가고, UPDATE를 수행할 수 없음(실패)
따라서 UPDATE에 대해 영향받은 ROW에 대해 ROLLBACK 처리
*/



SELECT DEPTNO, ENAME, SAL FROM EMP
WHERE DEPTNO=10;


DELETE FROM EMP WHERE DEPTNO = 20;
DELETE FROM EMP WHERE DEPTNO = 10;

ROLLBACK;


SELECT * FROM EMP;

SELECT * FROM EMP_B;



-- EMP 테이블 복사
ROLLBACK;
CREATE TABLE EMP_B AS SELECT * FROM EMP;
SELECT * FROM EMP;
DELETE FROM EMP_B;
SELECT * FROM EMP_B;

INSERT INTO EMP (SELECT * FROM EMP_B);
COMMIT;

SELECT * FROM EMP WHERE DEPTNO=10 FOR UPDATE WAIT 10;


COMMIT;



CREATE TABLE EMP_TEST AS SELECT * FROM EMP WHERE DEPTNO = 10;

MERGE INTO EMP_TEST T USING EMP E ON (T.EMPNO = E.EMPNO)
    WHEN MATCHED THEN UPDATE SET T.SAL = E.SAL * 1.3
    WHEN NOT MATCHED THEN INSERT VALUES (E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO);
    
SELECT * FROM EMP_TEST;




